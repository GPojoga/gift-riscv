
.section .text
	.globl main

	SUBST: # SubCells | substitute a single nibble
		
		mv t4, zero # counter
		li t5, 8 # limit for while

		DO_0:
		
		andi t1, t0, 0xf # mask the rightmost nibble
		div t2, t1, s5 # find the byte in the s-box
		rem t3, t1, s5 # 0:left-most nibble | 1:right-most nibble
		xori t3, t3, 1 # 1:left-most nibble | 0:right-most nibble
		mul t3, t3, s6 # 4:left-most nibble | 0:right-most nibble
		add t1, s11, t2 # compute address of substitution byte
		lb t1, 0(t1) # load substitution byte
		srl t1, t1, t3 # subst. nibble is the right most
		slli t1, t1, 28 # subst. nibble is the left most in 32-bit word
		srli t0, t0, 4 # shift plaintext to right by 1 nibble
		or t0, t0, t1 # introduce substituted nibble in the plaintext
		
		addi t4, t4, 1 # increment counter
		WHILE_0: bne t4, t5, DO_0 # while t4 < t5 
		
		jalr zero, 0(ra) # return

	PERM:
		mv t2, zero # counter
		li t3, 32 # limit for while

		DO_1:
			lb t4, 0(s5) # load the new position
			mv t5, t0 # make a copy of input
			
			li t1, 31
			sub t6, t1, t2 # compute the left shift : t6 = 31 - pos
			sll t5, t5, t6 # clear left bits | _
			srli t5, t5, 31 # clear right bits | used instead of mask

			blt t4, t3, CASE_1 # new pos < 32
			li t1, 64
			blt t4, t1, CASE_2 # new pos < 64
			li t1, 96
			blt t4, t1, CASE_3 # new pos < 96
			jal zero, CASE_4 # new pos < 128 
			CASE_1:
				sll t5, t5, t4 # move to the new position
				or s6, s6, t5 # store the result | block 0

				jal zero, DONE_1
			CASE_2:
				addi t4, t4, -32 # correct new pos | new_pos = new_pos - 32
				sll t5, t5, t4 # move to the new position
				or s7, s7, t5 # store the result | block 1
				jal zero, DONE_1
			CASE_3:
				addi t4, t4, -64 # new pos = new pos - 64
				sll t5, t5, t4 # move to the new position
				or s8, s8, t5 # store the result | block 2
				jal zero, DONE_1
			CASE_4:
				addi t4, t4, -96 # new pos = new pos - 96
				sll t5, t5, t4 # move to the new position
				or s9, s9, t5 # store the result | block 3
			DONE_1:

			addi s5, s5, 1 # increment p-box location 
			addi t2, t2, 1 # increment counter
		WHILE_1: bne t2, t3, DO_1 # while t2 < t3
		
		jalr zero, 0(ra) # return

	KEY:
		#---add round key---
		mv t0, a5	   # _ 
		sll t0, t0, 16 # _
		or t0, t0, a4  # Set U = k_5 || k_4
		
		mv t1, a1	   # _
		sll t1, t1, 16 # _
		or t1, t1, a0  # Set V = k_1 || k_0
		DEBUG1:
		mv t2, s0 # copy text block 0
		jal tp, ADDKEY
		mv s0, t2
		DEBUG2:
		mv t2, s1
		jal tp, ADDKEY
		mv s1, t2

		mv t2, s2
		jal tp, ADDKEY
		mv s2, t2

		mv t2, s3
		jal tp, ADDKEY
		mv s3, t2

		#---add round constant---

		mv t0, zero # counter
		li t1, 6 # while_bound
		li t2, 3 # i for b_i
		DO_4:
		
		mv t3, s4 # copy round constant
		srl t3, t3, t0
		andi t3, t3, 0x1 # mask the right most bit : c_1
		sll t3, t3, t2 # match b_7
		xor s0, s0, t3 # apply round constant

		addi t2, t2, 4 # increment i of b_i
		addi t0, t0, 1 # increment counter
		WHILE_4: bne t0, t1, DO_4 # while t0 < t1		
		
		li t0, 0x80000000
		xor s3, s3, t0 # b_{n-1} = b_{n-1} xor 1

		#---update key---
		mv t0, a0 # copy k_0
		srli t0, t0, 12 # k_0 >> 12
		slli a0, a0, 20 # isolate the trucated 12 bits
		srli a0, a0, 16 # move trucated bits to the right position
		or t0, t0, a0 # k_0 >>> 12

		mv t1, a1 # copy k_1
		srli t1, t1, 2 # k_1 >> 2
		andi a1, a1, 0x3 # isolate the truncated 2 bits
		slli a1, a1, 14 # move truncated bits to the right position
		or t1, t1, a1 # k_1 >>> 2

		mv a0, a2
		mv a1, a3
		mv a2, a4
		mv a3, a5
		mv a4, a6
		mv a5, a7
		mv a6, t0
		mv a7, t1

		#---update round constant---

		mv t4, s4
		mv t5, s4 

		srli t4, t4, 4
		srli t5, t5, 5

		andi t4, t4, 0x1 # isolated c_4
		andi t5, t5, 0x1 # isolated c_5

		xor t4, t4, t5 # c_4 xor c_5
		xori t4, t4, 0x1 # c_4 xor c_5 xor 1

		slli s4, s4, 1 # c << 1
		or s4, s4, t4 # c_0 = c_4 xor c_5 xor 1
		
		jalr zero, 0(ra) # return

	ADDKEY:
		mv t3, zero # counter
		li t4, 8 # limit 8
		DO_2:
			andi t5, t0, 0x1 # isolate right most bit of U
			andi t6, t1, 0x1 # isolate right most bit of V
			
			slli s11, t3, 2 # 4i
			addi s11, s11, 1 # 4i + 1
			sll t6, t6, s11 # v_{4i + 1}
			addi s11, s11, 1 # 4i + 2
			sll t5, t5, s11 # u_{4i + 2}
			
			xor t2, t2, t5 # b_{4i+2} <- b_{4i+2} xor u_i
			xor t2, t2, t6 # b_{4i+1} <- b_{4i+1} xor v_i

			srli t0, t0, 1 # update right most bit of U
			srli t1, t1, 1 # update the right most bit of U
		addi t3, t3, 1
		WHILE_2: bne t3, t4, DO_2 # while counter < 8
		jalr zero, 0(tp)

	main:
		#---Initialization---
		la t0, txt3 # plaintext
		lw s0, 12(t0)
		lw s1, 8(t0)
		lw s2, 4(t0)
		lw s3, 0(t0)
		
		li s4, 0x1 # round constant

		la t0, key3 # key
		li t1, 0xffff # when hw is loaded unused bits are set to 1. we must clean it
		lh a1, 14(t0)
		and a1, a1, t1
		lh a2, 8(t0)
		and a2, a2, t1
		lh a3, 10(t0)
		and a3, a3, t1
		lh a4, 4(t0)
		and a4, a4, t1
		lh a5, 6(t0)
		and a5, a5, t1
		lh a6, 0(t0)
		and a6, a6, t1
		lh a7, 2(t0)
		and a7, a7, t1
		lh a0, 12(t0)
		and a0, a0, t1
		#--------------------

		li s10, 40 # loop count
		
		DO_3:
		#---SubCells---
		SubCells:
			la s11, s_box # get sbox address
			li s5, 2 # constant : used for division 
			li s6, 4 # constant : used for multiplication
			
			mv t0, s0 # process 1st 32-bits
			jal SUBST
			mv s0, t0
			
			mv t0, s1 # process 2nd 32-bits
			jal SUBST
			mv s1, t0

			mv t0, s2 # process 3rd 32-bits
			jal SUBST
			mv s2, t0

			mv t0, s3 # process 4th 32-bits
			jal SUBST
			mv s3, t0
		#--------------
		#---PermBits---
		PermBits:
			la s5, p_box # address of  the p-box
			mv s6, zero # new block 0 
			mv s7, zero # new block 1 
			mv s8, zero # new block 2 
			mv s9, zero # new block 3 

			mv t0, s0 # process old block 0
			jal PERM
			mv t0, s1 # process old block 1
			jal PERM
			mv t0, s2 # process old block 2
			jal PERM
			mv t0, s3 # process old block 3
			jal PERM
			
			mv s0, s6 # store results
			mv s1, s7
			mv s2, s8
			mv s3, s9
		#--------------
		#---AddRoundKey---
		AddRoundKey:
		jal KEY
		#-----------------
		addi s10, s10, -1 # decrement loop count
		WHILE_3: bne s10, zero, DO_3 # loop count != zero
		END: j END

.section .rodata
	txt1: .word 0x0, 0x0, 0x0, 0x0 
	key1: .word 0x0, 0x0, 0x0, 0x0

	txt2: .word 0xfedcba98, 0x76543210, 0xfedcba98, 0x76543210 
	key2: .word 0xfedcba98, 0x76543210, 0xfedcba98, 0x76543210 

	txt3: .word 0xe39c141f, 0xa57dba43, 0xf08a85b6, 0xa91f86c1
	key3: .word 0xd0f5c59a, 0x7700d3e7, 0x99028fa9, 0xf90ad837 
 
	s_box: .byte 0x1a, 0x4c, 0x6f, 0x39, 0x2d, 0xb7, 0x50, 0x8e
	p_box: .byte 0, 33, 66, 99, 96, 1, 34, 67, 64, 97, 2, 35, 32, 65, 98, 3, 4, 37, 70, 103, 100, 5, 38, 71, 68, 101, 6, 39, 36, 69, 102, 7, 8, 41, 74, 107, 104, 9, 42, 75, 72, 105, 10, 43, 40, 73, 106, 11, 12, 45, 78, 111, 108, 13, 46, 79, 76, 109, 14, 47, 44, 77, 110, 15, 16, 49, 82, 115, 112, 17, 50, 83, 80, 113, 18, 51, 48, 81, 114, 19, 20, 53, 86, 119, 116, 21, 54, 87, 84, 117, 22, 55, 52, 85, 118, 23, 24, 57, 90, 123, 120, 25, 58, 91, 88, 121, 26, 59, 56, 89, 122, 27, 28, 61, 94, 127, 124, 29, 62, 95, 92, 125, 30, 63, 60, 93, 126, 31
